<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Christmas Tree</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Helvetica Neue', sans-serif; }
        
        /* UI è¦†ç›–å±‚ */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: #D4AF37; /* é‡‘è‰² */
            pointer-events: none;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        .status {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #ccc;
        }

        #upload-btn {
            pointer-events: auto;
            background: rgba(212, 175, 55, 0.2);
            border: 1px solid #D4AF37;
            color: #D4AF37;
            padding: 10px 20px;
            margin-top: 15px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            font-size: 0.8rem;
        }

        #upload-btn:hover {
            background: #D4AF37;
            color: #000;
            box-shadow: 0 0 15px #D4AF37;
        }

        /* æ‘„åƒå¤´å°çª— */
        #camera-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid #D4AF37;
            border-radius: 10px;
            overflow: hidden;
            z-index: 100;
            background: #000;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        #input_video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* é•œåƒ */
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        /* åŠ è½½æŒ‡ç¤ºå™¨ */
        #loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #D4AF37;
            font-size: 1.2rem;
            z-index: 200;
        }

        input[type="file"] { display: none; }
    </style>
    
    <!-- Import Maps -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js",
                "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
            }
        }
    </script>
    <!-- TWEEN.js for smooth animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <!-- MediaPipe Hands Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">ç³»ç»Ÿåˆå§‹åŒ–ä¸­... è¯·æˆäºˆæ‘„åƒå¤´æƒé™</div>

    <div id="ui-layer">
        <h1>XMAS PHOTO CLOUD</h1>
        <div class="status" id="status-text">ç­‰å¾…æ‰‹åŠ¿æŒ‡ä»¤...</div>
        <div class="status" style="font-size: 0.8rem; margin-top:5px; opacity: 0.7;">
            âœŠ æ¡æ‹³ï¼šèšåˆåœ£è¯æ ‘<br>
            ğŸ– äº”æŒ‡ï¼šæ•£å¼€ç…§ç‰‡äº‘<br>
            ğŸ‘‹ æ—‹è½¬æ‰‹è…•ï¼šæ§åˆ¶è§†è§’<br>
            ğŸ¤ æåˆï¼šæŠ“å–/æ”¾å¤§ç…§ç‰‡
        </div>
        <button id="upload-btn" onclick="document.getElementById('file-input').click()">ä¸Šä¼ ç…§ç‰‡</button>
        <input type="file" id="file-input" multiple accept="image/*">
    </div>

    <div id="camera-container">
        <video id="input_video" playsinline></video>
        <canvas id="output_canvas" width="200" height="150" style="position:absolute; top:0; left:0; pointer-events:none; transform: scaleX(-1);"></canvas>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- å…¨å±€é…ç½® ---
        const CONFIG = {
            colors: {
                green: 0x2F4F4F, // å“‘å…‰ç»¿
                gold: 0xFFD700,  // é‡‘è‰²
                red: 0x8B0000,   // åœ£è¯çº¢
                bg: 0x050505     // æ·±é»‘èƒŒæ™¯
            },
            count: 400, // æ€»ç²’å­æ•°
            photoCount: 0, // åˆå§‹ç…§ç‰‡æ•°ï¼ˆéšä¸Šä¼ å¢åŠ ï¼‰
            radius: 15, // æ ‘åº•éƒ¨åŠå¾„
            height: 35  // æ ‘é«˜
        };

        const STATE = {
            TREE: 'tree',
            SCATTER: 'scatter',
            ZOOM: 'zoom'
        };

        let currentState = STATE.TREE;
        let elements = []; // å­˜å‚¨æ‰€æœ‰3Då¯¹è±¡
        let photoElements = []; // ä¸“é—¨å­˜å‚¨ç…§ç‰‡å¯¹è±¡
        let uploadedTextures = [];
        
        // åœºæ™¯ç»„ä»¶
        let scene, camera, renderer, composer;
        let sceneGroup; // åŒ…å«æ‰€æœ‰ç²’å­çš„ç»„ï¼Œç”¨äºæ—‹è½¬
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2(); // ç”¨äºæ˜ å°„æ‰‹éƒ¨ä½ç½®

        // çŠ¶æ€æ ‡è®°
        let isTransitioning = false;
        let lastHandPos = { x: 0.5, y: 0.5 };
        let zoomedObject = null;
        let originalZoomPos = new THREE.Vector3();

        // DOM å…ƒç´ 
        const statusText = document.getElementById('status-text');
        const loader = document.getElementById('loader');

        // --- 1. Three.js åˆå§‹åŒ– ---
        function initThree() {
            const container = document.getElementById('canvas-container');

            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.02);

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 60);
            camera.lookAt(0, 15, 0);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            // ç»„
            sceneGroup = new THREE.Group();
            scene.add(sceneGroup);

            // ç¯å…‰ (è¥é€ é«˜çº§æ„Ÿ)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);

            const spotLight = new THREE.SpotLight(CONFIG.colors.gold, 50);
            spotLight.position.set(20, 50, 20);
            spotLight.angle = Math.PI / 4;
            spotLight.penumbra = 0.5;
            scene.add(spotLight);

            const redLight = new THREE.PointLight(CONFIG.colors.red, 20, 50);
            redLight.position.set(-20, 10, 20);
            scene.add(redLight);

            const goldLight = new THREE.PointLight(CONFIG.colors.gold, 20, 50);
            goldLight.position.set(0, 30, -20);
            scene.add(goldLight);

            // åå¤„ç† (è¾‰å…‰)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = 1.2; // è¾‰å…‰å¼ºåº¦
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // å¡«å……é»˜è®¤ç²’å­
            generateParticles();

            // çª—å£è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
        }

        // --- 2. å‡ ä½•ä½“ç”Ÿæˆé€»è¾‘ ---

        // ç”Ÿæˆæ ‘å½¢åæ ‡
        function getTreePosition(index, total) {
            const y = (index / total) * CONFIG.height; // 0 to height
            const radiusAtY = CONFIG.radius * (1 - y / CONFIG.height); // åº•éƒ¨å®½ï¼Œé¡¶éƒ¨å°–
            const angle = index * 0.5; // èºæ—‹
            const x = Math.cos(angle) * radiusAtY;
            const z = Math.sin(angle) * radiusAtY;
            return new THREE.Vector3(x, y, z);
        }

        // ç”Ÿæˆæ•£å¼€åæ ‡
        function getScatterPosition() {
            const r = 40 * Math.cbrt(Math.random());
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta) + 15; // ç¨å¾®æŠ¬é«˜ä¸­å¿ƒ
            const z = r * Math.cos(phi);
            return new THREE.Vector3(x, y, z);
        }

        function createMaterial(type) {
            if (type === 'gold') {
                return new THREE.MeshStandardMaterial({
                    color: CONFIG.colors.gold,
                    metalness: 1.0,
                    roughness: 0.1,
                    emissive: 0x222200
                });
            } else if (type === 'red') {
                return new THREE.MeshPhysicalMaterial({
                    color: CONFIG.colors.red,
                    metalness: 0.1,
                    roughness: 0.1,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.1
                });
            } else if (type === 'green') {
                return new THREE.MeshStandardMaterial({
                    color: CONFIG.colors.green,
                    metalness: 0.0,
                    roughness: 0.9,
                });
            }
        }

        function generateParticles() {
            // æ¸…ç†æ—§å¯¹è±¡
            elements.forEach(el => sceneGroup.remove(el.mesh));
            elements = [];
            photoElements = [];

            const total = CONFIG.count + uploadedTextures.length * 5; // è¿™é‡Œçš„ç³»æ•°æ˜¯ä¸ºäº†è®©ç…§ç‰‡åœ¨æ ‘ä¸­å¤šæ¬¡å‡ºç°ï¼Œå¢åŠ ä¸°æ»¡åº¦
            
            const geomSphere = new THREE.SphereGeometry(0.5, 16, 16);
            const geomBox = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            
            const matGold = createMaterial('gold');
            const matRed = createMaterial('red');
            const matGreen = createMaterial('green');

            let texIndex = 0;

            for (let i = 0; i < total; i++) {
                let mesh;
                let type = 'deco';

                // å†³å®šæ˜¯è£…é¥°ç‰©è¿˜æ˜¯ç…§ç‰‡
                // å¦‚æœæœ‰ä¸Šä¼ ç…§ç‰‡ï¼Œæ¯éš”å‡ ä¸ªç²’å­æ’å…¥ä¸€å¼ ç…§ç‰‡
                if (uploadedTextures.length > 0 && i % 10 === 0) {
                    const tex = uploadedTextures[texIndex % uploadedTextures.length];
                    texIndex++;
                    const aspect = tex.image.width / tex.image.height;
                    const geomPlane = new THREE.PlaneGeometry(3 * aspect, 3);
                    const matPhoto = new THREE.MeshBasicMaterial({ 
                        map: tex, 
                        side: THREE.DoubleSide,
                        transparent: true
                    });
                    mesh = new THREE.Mesh(geomPlane, matPhoto);
                    type = 'photo';
                    photoElements.push(mesh);
                } else {
                    // è£…é¥°ç‰©éšæœº
                    const r = Math.random();
                    if (r < 0.6) {
                        mesh = new THREE.Mesh(geomSphere, matGreen); // æ ‘å¶çƒ
                        mesh.scale.set(1.5, 1.5, 1.5);
                    } else if (r < 0.8) {
                        mesh = new THREE.Mesh(geomSphere, matRed); // çº¢çƒ
                    } else {
                        mesh = new THREE.Mesh(geomBox, matGold); // ç¤¼ç‰©/é‡‘é¥°
                    }
                }

                // è®¡ç®—ä½ç½®
                const treePos = getTreePosition(i, total);
                const scatterPos = getScatterPosition();

                // åˆå§‹ä½ç½®è®¾ä¸ºæ ‘å½¢æ€
                mesh.position.copy(treePos);
                
                // éšæœºæ—‹è½¬
                mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);

                // å­˜å‚¨æ•°æ®
                mesh.userData = {
                    treePos: treePos,
                    scatterPos: scatterPos,
                    type: type,
                    originalScale: mesh.scale.clone()
                };

                sceneGroup.add(mesh);
                elements.push(mesh);
            }
        }

        // --- 3. äº¤äº’ä¸åŠ¨ç”»é€»è¾‘ ---

        function toState(newState) {
            if (currentState === newState || isTransitioning) return;
            
            // çŠ¶æ€é”ï¼Œé˜²æ­¢æ‰‹åŠ¿æŠ–åŠ¨é¢‘ç¹è§¦å‘
            if(currentState === STATE.ZOOM && newState !== STATE.SCATTER) return; // æ”¾å¤§æ—¶åªèƒ½å˜å›æ•£å¼€

            console.log(`Switching to ${newState}`);
            statusText.innerText = newState === STATE.TREE ? "çŠ¶æ€ï¼šåœ£è¯æ ‘ (åˆæ‹¢)" : "çŠ¶æ€ï¼šç…§ç‰‡äº‘ (æ•£å¼€)";
            isTransitioning = true;
            currentState = newState;

            elements.forEach(mesh => {
                // å¦‚æœæ˜¯ZoomçŠ¶æ€ä¸‹çš„éç›®æ ‡ç‰©ä½“ï¼Œä¿æŒæ•£å¼€
                let target;
                if (newState === STATE.TREE) target = mesh.userData.treePos;
                else target = mesh.userData.scatterPos;

                // éšæœºå»¶è¿Ÿï¼Œäº§ç”Ÿè‡ªç„¶æ„Ÿ
                const delay = Math.random() * 500;
                
                new TWEEN.Tween(mesh.position)
                    .to({ x: target.x, y: target.y, z: target.z }, 1500)
                    .easing(TWEEN.Easing.Exponential.InOut)
                    .delay(delay)
                    .start();

                // æ—‹è½¬åŠ¨ç”»
                new TWEEN.Tween(mesh.rotation)
                    .to({ x: Math.random() * Math.PI * 2, y: Math.random() * Math.PI * 2 }, 1500)
                    .delay(delay)
                    .start();
            });

            // è§£é”
            setTimeout(() => { isTransitioning = false; }, 2000);
        }

        function zoomPhoto(screenX, screenY) {
            if (currentState !== STATE.SCATTER || isTransitioning) return;

            // Raycaster æ£€æµ‹
            mouse.x = (screenX * 2) - 1;
            mouse.y = -(screenY * 2) + 1; // ä¿®æ­£Yè½´æ–¹å‘

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(photoElements);

            if (intersects.length > 0) {
                const targetMesh = intersects[0].object;
                
                currentState = STATE.ZOOM;
                statusText.innerText = "çŠ¶æ€ï¼šç…§ç‰‡è¯¦æƒ…";
                zoomedObject = targetMesh;
                originalZoomPos.copy(targetMesh.position);

                // å°†é€‰ä¸­çš„ç…§ç‰‡ç§»åˆ°ç›¸æœºå‰æ–¹
                const cameraDirection = new THREE.Vector3();
                camera.getWorldDirection(cameraDirection);
                const targetPos = camera.position.clone().add(cameraDirection.multiplyScalar(10));

                new TWEEN.Tween(targetMesh.position)
                    .to({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, 1000)
                    .easing(TWEEN.Easing.Back.Out)
                    .start();
                
                new TWEEN.Tween(targetMesh.rotation)
                    .to({ x: camera.rotation.x, y: camera.rotation.y, z: camera.rotation.z }, 1000)
                    .start();
                
                new TWEEN.Tween(targetMesh.scale)
                    .to({ x: 3, y: 3, z: 3 }, 1000)
                    .start();
            }
        }

        function rotateView(handX, handY) {
            if (currentState === STATE.SCATTER) {
                // æ ¹æ®æ‰‹çš„ä½ç½®è½»å¾®æ—‹è½¬åœºæ™¯ç»„
                const targetRotY = (handX - 0.5) * 2; // -1 to 1
                const targetRotX = (handY - 0.5) * 1; 

                // ä½¿ç”¨ lerp å¹³æ»‘è¿‡æ¸¡
                sceneGroup.rotation.y += (targetRotY - sceneGroup.rotation.y) * 0.05;
                sceneGroup.rotation.x += (targetRotX - sceneGroup.rotation.x) * 0.05;
            } else if (currentState === STATE.TREE) {
                 sceneGroup.rotation.y += 0.005; // è‡ªåŠ¨æ—‹è½¬
            }
        }

        // --- 4. æ–‡ä»¶ä¸Šä¼ å¤„ç† ---
        document.getElementById('file-input').addEventListener('change', (event) => {
            const files = event.target.files;
            if (files.length > 0) {
                const loader = new THREE.TextureLoader();
                let loadedCount = 0;
                
                for (let i = 0; i < files.length; i++) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.src = e.target.result;
                        img.onload = () => {
                            const tex = new THREE.Texture(img);
                            tex.needsUpdate = true;
                            tex.colorSpace = THREE.SRGBColorSpace;
                            uploadedTextures.push(tex);
                            loadedCount++;
                            
                            if (loadedCount === files.length) {
                                // é‡æ–°ç”Ÿæˆåœºæ™¯
                                generateParticles();
                                // å¦‚æœå½“å‰æ˜¯æ•£å¼€æ€ï¼Œç›´æ¥åˆ‡åˆ°æ•£å¼€ä½ç½®
                                if(currentState === STATE.SCATTER) {
                                    elements.forEach(m => m.position.copy(m.userData.scatterPos));
                                }
                            }
                        }
                    };
                    reader.readAsDataURL(files[i]);
                }
            }
        });


        // --- 5. MediaPipe Hands é›†æˆ ---
        function onResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                // æ²¡æœ‰æ‰‹æ—¶ï¼Œå¦‚æœæ˜¯æ ‘çŠ¶æ€ï¼Œè®©å®ƒè‡ªè½¬
                if(currentState === STATE.TREE) sceneGroup.rotation.y += 0.002;
                return;
            }

            // è·å–ç¬¬ä¸€åªæ‰‹
            const landmarks = results.multiHandLandmarks[0];
            
            // ç»˜åˆ¶å°çª—
            const canvasCtx = document.getElementById('output_canvas').getContext('2d');
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, 200, 150);
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1});
            canvasCtx.restore();

            // === æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ ===
            
            // 1. è®¡ç®—å…³é”®ç‚¹
            const wrist = landmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];

            // è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—è·ç¦»
            const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

            // è¯†åˆ«æ¡æ‹³ (æŒ‡å°–é è¿‘æŒæ ¹ wrist)
            // ç®€å•çš„ heuristic: æŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦»éƒ½å¾ˆçŸ­
            const fingers = [indexTip, middleTip, ringTip, pinkyTip];
            const isFist = fingers.every(f => dist(f, wrist) < 0.35); // é˜ˆå€¼éœ€è°ƒè¯•

            // è¯†åˆ«äº”æŒ‡å¼ å¼€ (æŒ‡å°–ç¦»æ‰‹è…•è¿œ)
            const isOpen = fingers.every(f => dist(f, wrist) > 0.45);

            // è¯†åˆ«æåˆ (é£ŸæŒ‡ä¸æ‹‡æŒ‡è·ç¦»)
            const pinchDist = dist(thumbTip, indexTip);
            const isPinch = pinchDist < 0.05;

            // æ‰‹æŒä¸­å¿ƒï¼ˆè¿‘ä¼¼ï¼‰
            const handCenter = { x: landmarks[9].x, y: landmarks[9].y }; 

            // === çŠ¶æ€æœºè§¦å‘ ===

            if (isFist) {
                // å¦‚æœåœ¨æ”¾å¤§çŠ¶æ€ï¼Œå…ˆé€€å‡ºæ”¾å¤§
                if (currentState === STATE.ZOOM && zoomedObject) {
                     new TWEEN.Tween(zoomedObject.position).to(originalZoomPos, 500).start();
                     new TWEEN.Tween(zoomedObject.scale).to(zoomedObject.userData.originalScale, 500).start();
                     zoomedObject = null;
                     currentState = STATE.SCATTER;
                     setTimeout(() => toState(STATE.TREE), 500);
                } else {
                    toState(STATE.TREE);
                }
            } else if (isOpen) {
                if (currentState === STATE.ZOOM && zoomedObject) {
                     // é€€å‡ºæ”¾å¤§å›åˆ°æ•£å¼€
                     new TWEEN.Tween(zoomedObject.position).to(originalZoomPos, 500).start();
                     new TWEEN.Tween(zoomedObject.scale).to(zoomedObject.userData.originalScale, 500).start();
                     zoomedObject = null;
                     currentState = STATE.SCATTER;
                } else {
                    toState(STATE.SCATTER);
                }
            } else if (isPinch) {
                // åªæœ‰åœ¨æ•£å¼€çŠ¶æ€ä¸‹æ‰èƒ½æŠ“å–
                if (currentState === STATE.SCATTER) {
                    zoomPhoto(handCenter.x, handCenter.y);
                }
            }

            // === æŒç»­æ§åˆ¶ ===
            // æ§åˆ¶è§†è§’
            if (currentState === STATE.SCATTER && !isPinch) {
                rotateView(handCenter.x, handCenter.y);
            }
        }

        // --- 6. å¯åŠ¨ä¸å¾ªç¯ ---
        async function startApp() {
            initThree();
            
            const videoElement = document.getElementById('input_video');
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });
            
            hands.onResults(onResults);
            
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });
            
            cameraUtils.start().then(() => {
                loader.style.display = 'none';
                console.log("Camera started");
            });

            animate();
        }

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            
            // ç®€å•çš„ idle åŠ¨ç”»
            if(currentState === STATE.TREE && !isTransitioning) {
                 // ç²’å­å¾®å¾®æµ®åŠ¨
                 const t = time * 0.001;
                 elements.forEach((mesh, i) => {
                     mesh.position.y += Math.sin(t + i) * 0.005;
                 });
            }

            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start
        startApp();

    </script>
</body>
</html>